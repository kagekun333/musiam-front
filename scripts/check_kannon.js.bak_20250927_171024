// scripts/check_kannon.js
const fs = require("fs");
const path = require("path");

const DATA_DIR = path.join(__dirname, "..", "src", "data", "kannon100");

const reHeading = /^第[\u4E00-\u9FFF\d\s]{1,6}(吉|凶)/;        // 例: 第五 小吉 / 第一 大吉
const isPoemTitle = s => /^[\u4E00-\u9FFF]{2,12}$/.test(s) && !/[：:。！，、．,.]/.test(s);
const isSentence   = s => /。/.test(s);
const isLabelLine  = s => /^[\u4E00-\u9FFF]{1,12}[：:]/.test(s) && s.length < 30;

const LABEL_KEYS = ["願望","疾病","盼望的人","遺失物","失物","蓋新居","搬家","嫁娶","旅行","交往","商売","求財","學業","訴訟","萬事"];

function scoreText(raw) {
  const lines = (raw || "").split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  const res = { hasHeading:false, poemPairs:0, labels:0, hasCaution:false, reasons:[] };

  const h = lines.findIndex(s => reHeading.test(s));
  if (h >= 0) { res.hasHeading = true; } else { res.reasons.push("見出しNG"); }

  // 四句＋説明
  if (h >= 0) {
    let pairs = 0;
    for (let i = h+1; i < Math.min(lines.length, h+30); i++) {
      const t = lines[i];
      if (isLabelLine(t)) break;
      if (isPoemTitle(t)) {
        const next = lines[i+1] || "";
        if (next && isSentence(next)) { pairs++; i++; }
      }
    }
    res.poemPairs = pairs;
    if (pairs < 4) res.reasons.push(`四句+説明が${pairs}組`);
  }

  // ラベル群検出
  const labelHit = new Set();
  for (const ln of lines) {
    for (const k of LABEL_KEYS) {
      if (ln.startsWith(k+"：") || ln.startsWith(k+":")) labelHit.add(k);
    }
    if (/^萬事/.test(ln)) res.hasCaution = true;
  }
  res.labels = labelHit.size;
  if (res.labels < 3) res.reasons.push(`ラベル少(${res.labels})`);
  if (!res.hasCaution) res.reasons.push("注意書き無し");

  return res;
}

function exists(p){ try{ fs.accessSync(p); return true; } catch{ return false; } }

function run(){
  if (!fs.existsSync(DATA_DIR)) {
    console.error("DATA_DIR not found:", DATA_DIR);
    process.exit(1);
  }
  const rows = [];
  let ok = 0, ng = 0;

  for (let n=1; n<=100; n++){
    const pad = String(n).padStart(3,"0");
    const dir = path.join(DATA_DIR, pad);
    const textPath = path.join(dir, `原文${pad}.txt`);
    const front = path.join(dir, "front.jpg");
    const back  = path.join(dir, "back.jpg");

    let status="OK", reasons=[];
    let sc = {hasHeading:false,poemPairs:0,labels:0,hasCaution:false,reasons:[]};

    if (!exists(textPath)) {
      status = "NO_TEXT";
      reasons.push("原文ファイル無し");
    } else {
      const raw = fs.readFileSync(textPath, "utf8");
      sc = scoreText(raw);
      if (!(sc.hasHeading && sc.poemPairs>=4 && sc.labels>=3 && sc.hasCaution)) {
        status = "NEEDS_FIX";
        reasons = sc.reasons;
      }
    }

    const hasFront = exists(front);
    const hasBack  = exists(back);
    if (!hasFront || !hasBack) {
      status = status==="OK" ? "NEEDS_FIX" : status;
      if (!hasFront) reasons.push("front.jpg無し");
      if (!hasBack)  reasons.push("back.jpg無し");
    }

    (status==="OK") ? ok++ : ng++;

    rows.push({
      number:n,
      status,
      heading: sc.hasHeading ? 1 : 0,
      pairs: sc.poemPairs,
      labels: sc.labels,
      caution: sc.hasCaution ? 1 : 0,
      front: hasFront ? 1 : 0,
      back: hasBack ? 1 : 0,
      reasons: reasons.join(" / ")
    });
  }

  // 出力
  const outCsv = path.join(DATA_DIR, "_check_report.csv");
  const header = "number,status,heading,pairs,labels,caution,front,back,reasons\n";
  fs.writeFileSync(outCsv, header + rows.map(r =>
    [r.number,r.status,r.heading,r.pairs,r.labels,r.caution,r.front,r.back,
     `"${r.reasons.replace(/"/g,'""')}"`].join(",")
  ).join("\n"), "utf8");

  console.log("---- Summary ----");
  console.log("OK:", ok, " / NeedsFix:", ng);
  console.log("CSV:", outCsv);

  // 画面にも上位の問題だけ一覧
  const topBad = rows.filter(r => r.status!=="OK").slice(0,15);
  if (topBad.length){
    console.log("\nSample issues:");
    for (const r of topBad) {
      console.log(`#${String(r.number).padStart(3,"0")}  ${r.status}  pairs=${r.pairs} labels=${r.labels} caution=${r.caution}  -> ${r.reasons}`);
    }
  }
}
run();
